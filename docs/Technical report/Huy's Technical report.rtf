{\rtf1\ansi\ansicpg1252\cocoartf1138
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww24300\viewh14600\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs28 \cf0 Technical Problems:\
	Ant build:\
		For the last 5 semesters, we have learned programming languages and we write them on IDEs. The good thing about IDE is that they do everything for us. They help us to write code fast, tell us syntax errors, manage our code, compile it and run it. So, many of us actually do not know how to compile a Java program by "javac" or writing a build file to build our work. For me, I learned C last 2 semesters ago and know how to write a simple "make" file. Then, I am required to write a make file for our Java game. We choose Ant because it is widely used in Java community and actually, NetBeans generates an Ant build file for every project. At the first time, I opened that generated file and took a look. It looked weird and I could not know how can it work. Actually, as Kevin said, Netbeans generated a wrong Ant file and for me, it just runs like a miracle. So, I researched about it. I read tutorials about how to write a simple Ant file.\
		After few hours, I got a simple file which can compile my project. Then, I faced a another problem: external files. In our game, we use several resource files, like beans.xml for Spring, fonts and a collection of names for monsters. Now, writing an Ant build file to bundle those files with the final jar file is difficult. The jar file simply cannot get those resource files. I looked deeply into our code, to see how we call external files. I changed the place to store them so that my final jar file knows where they are. It took me several hours to do such a boring job. And finally, I found the way to solve it. Using Ant, I copy beans.xml file to the build folder before zip it so that file will be inside the final jar file. For all other files, I put them into a "res" folder and copy it to the same folder with the jar file. The structure sounds not good but it works.\
		Then, we decided to try CloudBees. The nice thing about CloudBees is that it do the job for us: check code repository for changes, build the new code and email us if there is any problem. But, without a good Ant build file which can run tests before building, CloudBees can do nothing. So, I have to change the Ant file so that it will compile, run tests and if all tests are passed, we have the final jar file. The first problem is, I cannot run tests. Every time I run, I got the same ClassNotFoundException. It took me like 1 day to know where and how to put those test files so that Ant can run it. Then, the old problem occurred. Test cases are run in a different environment and all external files cannot be found. So, I tried to solve the old problem with a new way. I decided to leave it there for a few days. Then, with help from other friends, I made it. It is simpler than I expect: just put Test files in the same root folder with source files and JUnit can get all resource files when running tests.\
		That should be enough for Ant build file. I got some problems which could be solved easily if I worked on it before. I learned how to create an Ant build file. And I learned not to allow IDEs to do everything for us. Sometimes, we better do it ourselves.\
\
	\
	Line of Sight Generator:\
		We decided to implement Line of Sight to our game. Actually, it is quite important in our game because it is not only used by player but also by monsters. Monsters with line of sight can detect player and react intelligently. At first, Line of Sight looks simple and easy to implement. In fact, we created a generator in 1 hour, but, it looked horrible and was not accurate: Player can see through walls.\
		Then, we researched to see how people do it. We followed some tutorials and created several generators base on their algorithms. At the end, non of them is perfect and flexible enough. With a radius of 3 pixels, it looks ok, however when we increased the radius to 6 or more pixels, bugs occurred. On the other hand, some generators is so complicated with a lot of "if \'85 else" statements. So, we decided to think of an algorithm by ourselves. We tried about 2 or 3 days and got stuck. After few discussions, we came up with a good idea: using trigonometric.\
		Our algorithm is quite simple. We have a radius, can be any number. Then, we loop from 0 to 360 degrees with he step is 2 degrees (the smaller it is, the more accurate). For each degree , we calculate the coordinate of points, if the radius is 5, we will get 5 points. Coordinate of 1 point can be determined by "sine" and "cosine" of the degree. If one point is blocked by a Wall or any obstacle, we move to next degree. At the end, we will get a very nice line of sight. It sounds complicated but the actual implementation is very simple. And the nice thing about this algorithm is that we can increase the radius to a very large number. We can also easily implement line of sight from a lamp. It is simply loop from 0 to 90 degrees instead of 360.\
		Maybe someone else used this algorithm before us. However, we really created it by ourselves and we can learn something from it. There are many things that look easy to do. But when we actually do it, we will find that it is very difficult. We can make it happens, but making it looks perfect is very challenge.\
\
	Applying Scrum:\
		As an important part of this course, Scrum must be used to our game development process. There are 2 sprints and 6 weeks for each sprint. We learn basic theory about processes like RUP and Scrum. However, this is the first time that we have to strictly follow Scrum. Of course, there will be some problems and difficulties.\
		The very first rule in our team is that we have a daily meeting at 10pm, every day. Yes, we did it during the first three weeks. Then, we got problem. Because we also study other courses, we cannot work on this project every day. So, what is the point of having daily meeting on days that we did not do anything at all. After a discussion, we decided to have "couple of days" meeting which occurs every 2 to 4 days, depends on how much work we have done during those days. And we found out that it was more comfortable for all of us.\
		The second problem is about defining sprint backlogs. According to Scrum, we have to think carefully about what we are going to do in a sprint and define a sprint backlog for it. However, because we have a long sprint, we had to update the backlog frequently to match our development status. The first sprint was great since we addicted to work on this project and implemented more than what we expected to do. Actually, in sprint one, we completed some features which belong to sprint 2. Then, we cannot update the sprint 1 backlog because it will be too long, compare to the second sprint. As a result, the sprint two backlog become less useful than it needs to be. We really think we should only have 2 or 3 weeks sprints so that we can control the work better, have more chances to improve after each sprint and manage out time better.\
		The next problem is about testing. We know that writing tests at the same time with implementing features is a good practice. However, it hard to execute due to some reasons. First, writing tests is boring and implementing core features is much more exciting. So, we forgot testing and were addicted to working on the game. We implemented new features and tested them by playing the game. Secondly, sometimes we had to change out tests because we changed the model so heavily. Because we did not think carefully about defining method signatures and workflow of the game, we had to change them regularly to match out new features. As a result, tests must be updated as well. So, we decided to writing tests at the end of each sprint. However, after each sprint, we really do not know which ones to test, how to test them and there will be so much test cases. We confirmed that the code run smoothly because we played it thousand times. So, writing test became boring and useless (that is what we think, and now I know it is not true).\
		Because we do not have much test cases, it is very hard to refactor the code. Refactoring is important, but without tests, it is too risky. When I see a dirty code, I want to make it better. However, I cannot do it because there is no test to confirm that refactored code does not introduce new bugs. When the project become large, playing the game cannot make sure that refactored code is right.\
		So, we learned several things after applying Scrum in our project. First, sometimes, daily meeting is not efficient, especially when we do not work full time in a project. Secondly, having many short sprints is  better that a long sprint since we can update our rules and sprint backlog to match our development progress. The next lesson is: testing is crucial. Without testing, the whole development process is risky. Actual code will become dirty and cannot be refactored because we can not test the new code. That is what people called: Hope Driven Development. The last lesson is: Write test as soon as possible. Writing test late means it will become extremely boring and difficult. In some cases, we can even write test before implementing the actual code.}